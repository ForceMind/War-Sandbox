<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>War Sandbox â€” å®Œæ•´åŸå‹ v7ï¼ˆä¿®å¤è¿·é›¾é®æŒ¡å·±åŸï¼‰</title>
<style>
  :root{--bg:#0f1115;--panel:#171a21;--accent:#e2b714;--muted:#9aa4b2;--good:#3ccf91;--bad:#ff6b6b}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6e9ef;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto;gap:8px;padding:8px}
  header,footer{display:flex;align-items:center;gap:8px;background:var(--panel);border-radius:12px;padding:8px 12px}
  header h1{font-size:16px;margin:0 8px 0 0;letter-spacing:.5px}
  header .sep{flex:1}
  button,select,input{background:#212734;color:#e6e9ef;border:1px solid #2a3242;border-radius:10px;padding:6px 10px}
  button:hover{border-color:#3a4356}
  #hud{display:flex;gap:14px;align-items:center}
  #canvasWrap{position:relative;background:#0b0d11;border-radius:12px;overflow:hidden}
  #game{display:block;width:100%;height:100%}
  #tooltip{position:absolute;pointer-events:none;left:0;top:0;background:#11161f;border:1px solid #263044;border-radius:8px;padding:6px 8px;font-size:12px;opacity:0;transition:opacity .08s}
  #bn{position:absolute;left:50%;top:12px;transform:translateX(-50%);font-weight:600;background:#11161f;border:1px solid #2a3242;border-radius:999px;padding:6px 12px;font-size:12px;opacity:.9}
  #events{display:flex;gap:8px;flex-wrap:wrap}
  .pill{background:#11161f;border:1px solid #2a3242;border-radius:999px;padding:4px 10px;font-size:12px;opacity:.9}
  .good{border-color:rgba(60,207,145,.35);color:var(--good)}
  .bad{border-color:rgba(255,107,107,.35);color:var(--bad)}
  #cityPanel{position:absolute;right:10px;top:50px;background:var(--panel);border-radius:12px;padding:10px;display:none;flex-direction:column;gap:8px;width:240px}
  #cityPanel h3{margin:0;font-size:14px}
  .sliderRow{display:flex;align-items:center;gap:6px}
  .sliderRow span.label{min-width:48px;display:inline-block}
  #legend{position:absolute;left:10px;top:50px;background:var(--panel);border-radius:12px;padding:8px 10px;font-size:12px;line-height:1.6;opacity:.95}
  #legend .dot{display:inline-block;width:10px;height:10px;margin-right:6px;vertical-align:middle}
  #legend .circle{border-radius:50%}
  #legend .triangle{width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:10px solid #4da3ff;margin-right:6px;display:inline-block}
  #legend .square{width:10px;height:10px;background:#4da3ff;display:inline-block;margin-right:6px}
  #legend .diamond{width:10px;height:10px;transform:rotate(45deg);background:#4da3ff;display:inline-block;margin-right:6px}
  #legend .rect{width:14px;height:8px;background:#4da3ff;display:inline-block;margin-right:6px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>War Sandbox</h1>
    <div id="hud">
      <span>åŸæ±  <b id="statCities">0</b></span>
      <span>æ€»å…µåŠ› <b id="statUnits">0</b></span>
      <span>ç”¨æ—¶ <b id="statTime">0:00</b></span>
      <span>é€Ÿåº¦ <b id="statSpeed">1x</b></span>
    </div>
    <div class="sep"></div>
    <button id="btnPause" title="P">æš‚åœ</button>
    <button id="btnSpeed">Ã—2</button>
    <button id="btnMute">é™éŸ³</button>
  </header>

  <div id="canvasWrap">
    <canvas id="game"></canvas>
    <div id="tooltip"></div>
    <div id="bn">æ‹–æ‹½å·±æ–¹åŸæ±  â†’ ç›®æ ‡åŸæ±  å‘èµ·å‡ºå¾ï¼ˆå•ä½è·¯ä¸Šé­é‡ä¼šè‡ªåŠ¨å¼€æˆ˜ï¼‰</div>
    <div id="legend">
      <div><span class="circle dot" style="background:#4da3ff"></span>æ­¥å…µ</div>
      <div><span class="triangle"></span>éª‘å…µ</div>
      <div><span class="square"></span>å¼“å…µ</div>
      <div><span class="diamond"></span>é•¿æªå…µ</div>
      <div><span class="rect"></span>æ”»åŸè½¦</div>
    </div>
    <div id="cityPanel">
      <h3 id="cityName">åŸæ± åç§°</h3>
      <div>ç­‰çº§ï¼š<span id="cityLevel"></span></div>
      <button id="btnUpgrade">å‡çº§åŸæ± </button>
      <div class="hint">äº§å…µæ¯”ä¾‹ï¼ˆæ€»è®¡ 100%ï¼‰</div>
      <div id="unitSliders"></div>
    </div>
    <div id="overlay" style="position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);">
      <div style="background:#171a21;border:1px solid #2a3242;border-radius:14px;min-width:320px;max-width:90vw;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);text-align:center">
        <h2 style="margin:4px 0 10px 0;font-size:18px">å±€åŠ¿åˆ¤å®š</h2>
        <div id="overlayText" style="color:#cdd6e6;line-height:1.6;margin-bottom:12px">ä½ å·²å¤±å»æ‰€æœ‰åŸæ± ã€‚</div>
        <div style="display:flex;gap:8px;justify-content:center">
          <button id="btnRestart">å†æ¥ä¸€å±€</button>
          <button id="btnObserve">ç»§ç»­è§‚æˆ˜</button>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <div id="events" aria-live="polite"></div>
    <div class="sep"></div>
    <div class="hint">æ“ä½œï¼šç‚¹å‡»å·±æ–¹åŸæ± æŸ¥çœ‹ï¼ŒæŒ‰ä½æ‹–æ‹½åˆ°ç›®æ ‡åŸæ± æ´¾å…µã€‚P æš‚åœï¼ŒÃ—2 åˆ‡æ¢å€é€Ÿã€‚</div>
  </footer>
</div>

<script>
(()=>{
'use strict';
/* =============================
   é…ç½®
============================= */
const COLORS = { PLAYER:'#4da3ff', AI1:'#ff6b6b', AI2:'#e2b714', NEUTRAL:'#7f8a9b' };
const TIME_SCALE_STEPS=[1,2,4];
const MAX_UNITS=1000; const CELL=60; const PROJECTILE_SPEED=320; const CAPTURE_SPEED=12; // æ¯ç§’å é¢†ç™¾åˆ†ç‚¹
const WALL_BASE=120; const WALL_REGEN=4; // æ¯ç§’æ¢å¤é‡ï¼ˆæ— æ•Œäººæ—¶ï¼‰
const PROD_TICK=1.0; const RALLY_PERCENT_DEFAULT=0.5; const VISION_UNIT=120; const VISION_CITY=180;
const REVERSE={ base:0.02, max:0.08, gapFactor:0.015 };

// å…µç§ï¼ˆä¸­æ–‡ï¼‰
const UNIT={
  æ­¥å…µ:{hp:60,  atk:8,  atkInt:0.6, move:45, range:14,  cost:1, shape:'circle'},
  éª‘å…µ:{hp:80,  atk:12, atkInt:0.7, move:70, range:14,  cost:2, shape:'triangle', charge:1.4},
  å¼“å…µ:{hp:45,  atk:7,  atkInt:0.8, move:50, range:130, cost:2, shape:'square'},
  é•¿æªå…µ:{hp:90,  atk:9,  atkInt:0.8, move:35, range:14,  cost:2, shape:'diamond'},
  æ”»åŸè½¦:{hp:220, atk:26, atkInt:1.4, move:22, range:48,  cost:5, shape:'rect', vsWall:2.2}
};
const COUNTER={ æ­¥å…µ:{å¼“å…µ:1.25}, éª‘å…µ:{å¼“å…µ:1.6}, å¼“å…µ:{æ­¥å…µ:1.1,é•¿æªå…µ:1.05}, é•¿æªå…µ:{éª‘å…µ:1.8}, æ”»åŸè½¦:{WALL:2.2} };
const ALL_TYPES=['æ­¥å…µ','å¼“å…µ','é•¿æªå…µ','éª‘å…µ','æ”»åŸè½¦'];

/* åˆå§‹åœ°å›¾ï¼šå¤šåŸæ±  + éšæœºè¡¥å…… */
const MAP={
  nodes:[
    {id:1,name:'ç‹éƒ½',pos:{x:.18,y:.58},level:2,owner:'PLAYER', prod:2.0,def:1.2, mix:{æ­¥å…µ:50,å¼“å…µ:20,é•¿æªå…µ:15,éª‘å…µ:15,æ”»åŸè½¦:0}},
    {id:2,name:'è’åŸå ¡',pos:{x:.42,y:.24},level:1,owner:'NEUTRAL',prod:1.2,def:1.0, mix:{æ­¥å…µ:80,å¼“å…µ:10,é•¿æªå…µ:10,éª‘å…µ:0,æ”»åŸè½¦:0}},
    {id:3,name:'çŸ¿è„‰é•‡',pos:{x:.70,y:.58},level:2,owner:'AI1',    prod:1.8,def:1.1, mix:{æ­¥å…µ:55,å¼“å…µ:25,é•¿æªå…µ:10,éª‘å…µ:10,æ”»åŸè½¦:0}},
    {id:4,name:'æ¸¡å£',  pos:{x:.36,y:.78},level:1,owner:'NEUTRAL',prod:1.1,def:.95, mix:{æ­¥å…µ:70,å¼“å…µ:15,é•¿æªå…µ:15,éª‘å…µ:0,æ”»åŸè½¦:0}},
    {id:5,name:'æ—ä¸˜',  pos:{x:.60,y:.35},level:1,owner:'NEUTRAL',prod:1.3,def:1.0, mix:{æ­¥å…µ:70,å¼“å…µ:20,é•¿æªå…µ:10,éª‘å…µ:0,æ”»åŸè½¦:0}},
    {id:6,name:'é©¿ç«™',  pos:{x:.25,y:.30},level:1,owner:'NEUTRAL',prod:1.2,def:1.0, mix:{æ­¥å…µ:70,å¼“å…µ:20,é•¿æªå…µ:10,éª‘å…µ:0,æ”»åŸè½¦:0}},
    {id:7,name:'æ—§å ¡',  pos:{x:.78,y:.22},level:1,owner:'NEUTRAL',prod:1.1,def:1.0, mix:{æ­¥å…µ:70,å¼“å…µ:20,é•¿æªå…µ:10,éª‘å…µ:0,æ”»åŸè½¦:0}}
  ],
  links:[[1,2],[2,3],[1,4],[4,2],[3,4],[2,5],[5,3],[1,6],[6,2],[3,7],[5,7]]
};

/* =============================
   å·¥å…·
============================= */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);
const dist2=(a,b)=>{const dx=a.x-b.x,dy=a.y-b.y;return dx*dx+dy*dy};
const nowMs=()=>performance.now();

/* =============================
   çŠ¶æ€
============================= */
const state={
  t:0,last:nowMs(),dt:0,speed:1,paused:false,
  width:0,height:0, dpr:1,
  nodes:[], edges:[], units:[], projs:[],
  grid:null,cols:0,rows:0,
  selected:null,dragTo:null,dragging:false,dragStart:null,
  rallyPercent:RALLY_PERCENT_DEFAULT,
  aiTimer:0, spawnTimer:8,
  gameOver:false
};

/* =============================
   DOM & äº‹ä»¶æ¡
============================= */
const cvs=document.getElementById('game');
const ctx=cvs.getContext('2d');
const tooltip=document.getElementById('tooltip');
const statCities=document.getElementById('statCities');
const statUnits=document.getElementById('statUnits');
const statTime=document.getElementById('statTime');
const statSpeed=document.getElementById('statSpeed');
const btnPause=document.getElementById('btnPause');
const btnSpeed=document.getElementById('btnSpeed');
const btnMute=document.getElementById('btnMute');
const overlay=document.getElementById('overlay');
const overlayText=document.getElementById('overlayText');
const btnRestart=document.getElementById('btnRestart');
const btnObserve=document.getElementById('btnObserve');
const cityPanel=document.getElementById('cityPanel');
const cityName=document.getElementById('cityName');
const cityLevel=document.getElementById('cityLevel');
const unitSliders=document.getElementById('unitSliders');
const btnUpgrade=document.getElementById('btnUpgrade');
const eventsEl=document.getElementById('events');

function pushEvent(text,type){
  const span=document.createElement('span');
  span.className='pill'+(type?(' '+type):'');
  span.textContent=text;
  eventsEl.prepend(span);
  while(eventsEl.children.length>3){ eventsEl.lastChild.remove(); }
  setTimeout(()=>{ if(span.isConnected) span.remove(); }, 4200);
}

/* =============================
   è‡ªé€‚åº”
============================= */
function resize(){
  const wrap=document.getElementById('canvasWrap');
  const w=wrap.clientWidth,h=wrap.clientHeight;
  const dpr=window.devicePixelRatio||1; state.dpr=dpr;
  cvs.width=w*dpr; cvs.height=h*dpr; cvs.style.width=w+'px'; cvs.style.height=h+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  state.width=w; state.height=h;
  for(const n of state.nodes){ n.x=n._nx*state.width; n.y=n._ny*state.height; }
  buildGrid();
}
window.addEventListener('resize',resize);

/* =============================
   ç½‘æ ¼
============================= */
function buildGrid(){ state.cols=Math.ceil(state.width/CELL); state.rows=Math.ceil(state.height/CELL); state.grid=Array.from({length:state.cols*state.rows},()=>({units:[]})); }
function cellIndex(x,y){ const cx=clamp(Math.floor(x/CELL),0,state.cols-1); const cy=clamp(Math.floor(y/CELL),0,state.rows-1); return cx+cy*state.cols; }
function gridClear(){ for(const c of state.grid) c.units.length=0; }
function gridInsert(u){ const idx=cellIndex(u.x,u.y); state.grid[idx].units.push(u); u._cell=idx; }

/* =============================
   åœ°å›¾ä¸èŠ‚ç‚¹
============================= */
function buildMap(){
  state.nodes = MAP.nodes.map(n=>({
    _isNode:true,
    id:n.id,
    name:n.name,
    _nx:n.pos.x,
    _ny:n.pos.y,
    x:0,
    y:0,
    level:n.level,
    owner:n.owner,
    prod:n.prod,
    def:n.def,
    mix:Object.assign({}, n.mix),
    wall:0,
    capture:0
  }));
  state.edges = MAP.links.map(([a,b])=>({a:byId(a), b:byId(b)}));
  resize();
  for(const nd of state.nodes){ nd.wall=WALL_BASE*nd.def*nd.level; }
  // åˆå§‹å®ˆå†›
  for(const nd of state.nodes){
    const fac=nd.owner;
    if(fac==='NEUTRAL') { spawnAtNode(nd,'NEUTRAL','æ­¥å…µ',8); }
    else if(fac==='PLAYER') { spawnAtNode(nd,fac,'æ­¥å…µ',12); spawnAtNode(nd,fac,'å¼“å…µ',6); spawnAtNode(nd,fac,'é•¿æªå…µ',4); }
    else { spawnAtNode(nd,fac,'æ­¥å…µ',10); spawnAtNode(nd,fac,'å¼“å…µ',4); }
  }
  state.gameOver=false; overlay.style.display='none';
}
function byId(id){ return state.nodes.find(n=>n.id===id); }

/* éšæœºæ–°åŸæ± ç”Ÿæˆï¼ˆæˆ˜äº‰è¿·é›¾ä¸‹æ‰©å±•ï¼‰*/
function spawnCity(){
  // åœ¨åœ°å›¾éšæœºä½ç½®ç”Ÿæˆä¸­ç«‹æˆ–AIåŸï¼Œé¿å…è¿‡è¿‘
  const x=rand(0.1,0.9)*state.width, y=rand(0.1,0.9)*state.height;
  for(const n of state.nodes){ if(Math.hypot(x-n.x,y-n.y)<140) return; }
  const id = state.nodes.length? Math.max(...state.nodes.map(n=>n.id))+1 : 1;
  const owner = Math.random()<0.6 ? 'NEUTRAL' : 'AI1';
  const level = Math.random()<0.7?1:2; const def=1+Math.random()*0.2; const prod=1+Math.random()*0.8;
  const node={_isNode:true,id,name:`é‡åŸ${id}`,_nx:x/state.width,_ny:y/state.height,x,y,level,owner,prod,def,mix:{æ­¥å…µ:70,å¼“å…µ:20,é•¿æªå…µ:10,éª‘å…µ:0,æ”»åŸè½¦:0},wall:WALL_BASE*def*level,capture:0};
  state.nodes.push(node);
  // è‡ªå‘å®ˆå†›
  if(owner!=='NEUTRAL') spawnAtNode(node,owner,'æ­¥å…µ',8);
  // è¿æ¥æœ€è¿‘ä¸¤åŸ
  let a=null,b=null, d1=1e12,d2=1e12; for(const n of state.nodes){ if(n===node) continue; const d=dist2(n,node); if(d<d1){d2=d1;b=a; d1=d; a=n;} else if(d<d2){ d2=d; b=n; } }
  if(a) state.edges.push({a,b:node}); if(b) state.edges.push({a:node,b});
  pushEvent(`${node.name} å‡ºç°åœ¨é›¾ä¸­`, 'bad');
}

/* =============================
   å•ä½ä¸å¼¹é“
============================= */
function makeUnit(opts){
  const t=UNIT[opts.type];
  return { alive:true, f:opts.f, type:opts.type, x:opts.x, y:opts.y, vx:0, vy:0,
    hp:t.hp, atk:t.atk, atkInt:t.atkInt, move:t.move, range:t.range,
    charge:t.charge||1, vsWall:t.vsWall||1, tAtk:0, target:null, destNode:null, r:6 };
}
function makeProj(x,y,tx,ty,from){ return {x,y,tx,ty,from,alive:true,spd:PROJECTILE_SPEED}; }

function nodeRadius(n){ return 28+8*(n.level-1); }
function spawnAtNode(n,f,type,count){ for(let i=0;i<count;i++){ if(state.units.length>=MAX_UNITS) return; const ang=Math.random()*Math.PI*2, rr=nodeRadius(n)-10; const u=makeUnit({f,type,x:n.x+Math.cos(ang)*rr,y:n.y+Math.sin(ang)*rr}); state.units.push(u);} }

/* =============================
   äº§å…µä¸æ´¾å…µï¼ˆå®Œå…¨æ‰‹åŠ¨å‡ºå¾ï¼‰
============================= */
function produce(dt){
  for(const n of state.nodes){ if(n.owner==='NEUTRAL') continue; n._prodAcc=(n._prodAcc||0)+dt*n.prod*state.speed; while(n._prodAcc>=PROD_TICK){ n._prodAcc-=PROD_TICK; const type=weightedPick(n.mix); spawnAtNode(n,n.owner,type,1); }}
}
function weightedPick(mix){ const arr=[]; for(const k in mix){ const v=Math.max(0,Math.round(mix[k])); for(let i=0;i<v;i++) arr.push(k);} return arr[Math.floor(Math.random()*arr.length)]||'æ­¥å…µ'; }

function dispatch(from,to,percent){
  if(!from||!to||from===to) return;
  const R=nodeRadius(from);
  const pool=state.units.filter(u=>u.f===from.owner && dist2(u,from)<=R*R);
  const send=Math.max(1,Math.floor(pool.length*percent));
  for(let i=0;i<send;i++){ const u=pool[i]; if(!u) break; u.destNode=to; u.target=null; } // ä¸è‡ªåŠ¨å¯»æ•Œï¼Œåªèµ°å‘ç›®æ ‡
  pushEvent(`å‡ºå¾ï¼š${from.name} â†’ ${to.name}ï¼ˆ${send}äººï¼‰`);
}

/* =============================
   æˆ˜æ–—ä¸å é¢†è§„åˆ™
============================= */
function counterCoef(att,def){ const co=COUNTER[att]||{}; return co[def]||1; }
function tryReverseKill(attacker, defender){
  const aPow=attacker.atk/attacker.atkInt*attacker.hp;
  const dPow=defender.atk/defender.atkInt*defender.hp;
  const gap=Math.max(0,(aPow/dPow)-1);
  const p=clamp(REVERSE.base+gap*REVERSE.gapFactor,REVERSE.base,REVERSE.max);
  if(Math.random()<p){ attacker.hp=0; attacker.alive=false; pushEvent('âš¡ æ¦‚ç‡åæ€ï¼','bad'); return true; }
  return false;
}

function updateUnits(dt){
  gridClear(); for(const u of state.units){ if(!u.alive) continue; gridInsert(u); }
  for(const u of state.units){ if(!u.alive) continue;
    // æ‰‹åŠ¨å‡ºå¾ï¼šå¹³æ—¶åªæŒ‰ destNode å‰è¿›ï¼›è‹¥é‡æ•Œï¼ˆé‚»åŸŸå†…ï¼‰å†å¼€æˆ˜
    let enemyNear=null, nd2=1e12; const cx=Math.floor(u.x/CELL), cy=Math.floor(u.y/CELL);
    for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
      const ix=cx+dx, iy=cy+dy; if(ix<0||iy<0||ix>=state.cols||iy>=state.rows) continue; const cell=state.grid[ix+iy*state.cols];
      for(const v of cell.units){ if(!v.alive||v.f===u.f) continue; const d2=dist2(u,v); if(d2<nd2){ nd2=d2; enemyNear=v; }}
    }
    if(enemyNear && Math.sqrt(nd2)<=Math.max(UNIT[u.type].range,26)){ u.target=enemyNear; } // é‡æ•Œåˆ™é”å®šï¼Œé˜»æ­¢ç©¿è¶Š

    // å¤„ç†æˆ˜æ–—æˆ–ç§»åŠ¨
    if(u.target && u.target.alive){
      const tgt=u.target; const dx=tgt.x-u.x, dy=tgt.y-u.y; const d=Math.hypot(dx,dy);
      if(d>u.range){ const sp=u.move*dt*state.speed*0.4; if(d>1){ u.x+=dx/d*sp; u.y+=dy/d*sp; } } // æ¥æ•Œé æ‹¢ï¼Œç§»åŠ¨å‡é€Ÿ
      else { u.tAtk-=dt*state.speed; if(u.tAtk<=0){ u.tAtk=u.atkInt; if(UNIT[u.type].range>40){ state.projs.push(makeProj(u.x,u.y,tgt.x,tgt.y,u)); } else { let dmg=u.atk*counterCoef(u.type,tgt.type); if(u.type==='éª‘å…µ') dmg*=u.charge; const killed=tryReverseKill(u,tgt); if(!killed){ tgt.hp-=dmg; if(tgt.hp<=0){ tgt.alive=false; pushEvent('å‡»æ€ +1','good'); u.target=null; } } } } }
    } else if(u.destNode){
      const n=u.destNode; const dx=n.x-u.x, dy=n.y-u.y; const d=Math.hypot(dx,dy);
      const R=nodeRadius(n)*0.9; if(d>R){ const sp=u.move*dt*state.speed; u.x+=dx/d*sp; u.y+=dy/d*sp; } else { /* åˆ°è¾¾åŸæ± ï¼Œç­‰å¾…å é¢†è§„åˆ™å¤„ç† */ }
    }
  }

  // å¼¹é“
  for(const p of state.projs){ if(!p.alive) continue; const dx=p.tx-p.x, dy=p.ty-p.y; const d=Math.hypot(dx,dy); if(d<6){ let hit=null, nd2=400; for(const u of state.units){ if(!u.alive||u.f===p.from.f) continue; const d2=dist2(u,p); if(d2<nd2){nd2=d2; hit=u;} } if(hit){ let dmg=p.from.atk*counterCoef(p.from.type,hit.type); hit.hp-=dmg; if(hit.hp<=0){ hit.alive=false; pushEvent('è¿œç¨‹å‡»æ€','good'); } } p.alive=false; } else { const sp=p.spd*dt*state.speed; p.x+=dx/d*sp; p.y+=dy/d*sp; } }

  state.units=state.units.filter(u=>u.alive);
  state.projs=state.projs.filter(p=>p.alive);
}

function topFactionIn(n){ const R=nodeRadius(n), R2=R*R; const count={}; for(const u of state.units){ if(dist2(u,n)<=R2){ count[u.f]=(count[u.f]||0)+1; }} let best=null,c=0; for(const f in count){ if(count[f]>c){c=count[f]; best=f;} } return best||null; }

function updateCaptureAndWall(dt){
  for(const n of state.nodes){
    // åŸé˜²æ¢å¤ï¼šä»…åœ¨åŸå†…æ²¡æœ‰æ•Œäººä¸”å½“å‰åŸé˜²æœªæ»¡æ—¶
    const R=nodeRadius(n); const R2=R*R; let friend=0, enemy=0; const count={};
    for(const u of state.units){ if(dist2(u,n)<=R2){ if(u.f===n.owner) friend++; else enemy++; count[u.f]=(count[u.f]||0)+1; }}
    const wallMax=WALL_BASE*n.def*n.level;
    if(enemy===0 && n.wall<wallMax){ n.wall = clamp(n.wall + WALL_REGEN*dt*state.speed, 0, wallMax); }

    if(n.wall>0){ n.capture=Math.max(0,n.capture-10*dt*state.speed); continue; }

    // å é¢†ï¼šå¿…é¡»åŸå†…æ— æ•Œäºº
    if(enemy===0){
      const top=topFactionIn(n);
      if(!top){ n.capture=Math.max(0,n.capture-6*dt*state.speed); continue; }
      if(top===n.owner){ n.capture=Math.max(0,n.capture-6*dt*state.speed); }
      else { n.capture+=CAPTURE_SPEED*dt*state.speed; if(n.capture>=100){ changeOwner(n, top); } }
    } else {
      // æ•Œæˆ‘åŒåœºï¼šä¸æ¨è¿›ï¼Œç¼“æ…¢å›è½
      n.capture=Math.max(0,n.capture-4*dt*state.speed);
    }
  }
}

function changeOwner(node,newOwner){ node.owner=newOwner; node.capture=0; node.wall=WALL_BASE*node.def*node.level; pushEvent(`ğŸ³ï¸ å é¢† ${node.name} æˆåŠŸ`,'good'); }

/* =============================
   AIï¼ˆç®€å•ï¼šå¶å°”æ‰©å¼ ï¼‰
============================= */
function updateAI(dt){
  if(state.gameOver) return; // ç»“ç®—æ—¶ä¸å†é©±åŠ¨AI
  state.aiTimer-=dt*state.speed; if(state.aiTimer<=0){ state.aiTimer=rand(3,6);
    const aiCities=state.nodes.filter(n=>n.owner==='AI1'); if(aiCities.length>0){
      const src=aiCities[Math.floor(Math.random()*aiCities.length)]; let best=null,bd2=1e12; for(const t of state.nodes){ if(t.owner!=='AI1'){ const d2=dist2(src,t); if(d2<bd2){bd2=d2; best=t;} } }
      if(best) dispatch(src,best,0.4);
    }
  }
}

/* =============================
   æ¸²æŸ“ï¼ˆå«æˆ˜äº‰è¿·é›¾ï¼‰
============================= */
function drawEdges(){ ctx.save(); ctx.strokeStyle='#1e242f'; ctx.lineWidth=2; for(const e of state.edges){ ctx.beginPath(); ctx.moveTo(e.a.x,e.a.y); ctx.lineTo(e.b.x,e.b.y); ctx.stroke(); } ctx.restore(); }
function drawNodes(){ for(const n of state.nodes){ const R=nodeRadius(n); ctx.save(); ctx.beginPath(); ctx.arc(n.x,n.y,R,0,Math.PI*2); ctx.fillStyle=(n.owner==='PLAYER')? '#0d2740' : (n.owner==='AI1')? '#401a1a' : '#1f2430'; ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle=(COLORS[n.owner]||'#4b5565'); ctx.stroke(); if(n.capture>0){ ctx.beginPath(); ctx.strokeStyle='#d6e0f5'; ctx.lineWidth=4; ctx.arc(n.x,n.y,R+4,-Math.PI/2,-Math.PI/2+Math.min(1,n.capture/100)*Math.PI*2); ctx.stroke(); } const wallPct=clamp(n.wall/(WALL_BASE*n.def*n.level),0,1); const bw=R*1.5,bh=6; ctx.fillStyle='#12161f'; ctx.fillRect(n.x-bw/2,n.y+R+8,bw,bh); ctx.fillStyle=wallPct>0.5?'#39d0a8':'#f1c40f'; if(wallPct>0) ctx.fillRect(n.x-bw/2,n.y+R+8,bw*wallPct,bh); ctx.fillStyle='#cdd6e6'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.fillText(`${n.name} Lv${n.level}`, n.x, n.y-R-8); ctx.restore(); } }
function drawUnits(){ for(const u of state.units){ ctx.save(); ctx.translate(u.x,u.y); ctx.fillStyle=(COLORS[u.f]||'#8899aa'); switch(UNIT[u.type].shape){ case 'circle': ctx.beginPath(); ctx.arc(0,0,3.5,0,Math.PI*2); ctx.fill(); break; case 'triangle': ctx.beginPath(); ctx.moveTo(0,-4); ctx.lineTo(4,4); ctx.lineTo(-4,4); ctx.closePath(); ctx.fill(); break; case 'square': ctx.fillRect(-3,-3,6,6); break; case 'diamond': ctx.beginPath(); ctx.moveTo(0,-4); ctx.lineTo(4,0); ctx.lineTo(0,4); ctx.lineTo(-4,0); ctx.closePath(); ctx.fill(); break; case 'rect': ctx.fillRect(-5,-3,10,6); break; } ctx.restore(); } ctx.save(); ctx.strokeStyle='#d8dee9'; ctx.lineWidth=1.5; for(const p of state.projs){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.tx,p.ty); ctx.stroke(); } ctx.restore(); }

function drawFog(){
  // ç©å®¶è§†é‡ï¼šå•ä½å’Œå·±æ–¹åŸæ± å¼€è§†é‡
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.65)';
  ctx.fillRect(0,0,state.width,state.height);
  ctx.globalCompositeOperation='destination-out';
  // 1) å·±æ–¹åŸæ± å¼€æ´
  for(const n of state.nodes){ if(n.owner==='PLAYER') { ctx.beginPath(); ctx.arc(n.x,n.y,Math.max(VISION_CITY, nodeRadius(n)+20),0,Math.PI*2); ctx.fill(); } }
  // 2) å·±æ–¹å•ä½å¼€æ´
  for(const u of state.units){ if(u.f==='PLAYER'){ ctx.beginPath(); ctx.arc(u.x,u.y,VISION_UNIT,0,Math.PI*2); ctx.fill(); } }
  ctx.restore();
}

function render(){
  ctx.clearRect(0,0,state.width,state.height);
  drawEdges();
  drawNodes();
  drawUnits();
  if(state.selected && state.dragTo){ const a=state.selected,b=state.dragTo; ctx.save(); ctx.strokeStyle='#d6e0f5'; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); ctx.setLineDash([]); ctx.restore(); }
  // è¿·é›¾ç›–åœ¨ä¸Šå±‚
  drawFog();
  // ä¸ºé¿å…ä¸ªåˆ«ç¯å¢ƒä¸‹åˆæˆå¼‚å¸¸ï¼Œæœ€åå†æŠŠå·±æ–¹åŸæ± /å•ä½é‡ç»˜ä¸€éç½®é¡¶
  ctx.save();
  for(const n of state.nodes){ if(n.owner==='PLAYER'){ const R=nodeRadius(n); ctx.beginPath(); ctx.arc(n.x,n.y,R,0,Math.PI*2); ctx.fillStyle='#0d2740'; ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle=(COLORS[n.owner]||'#4b5565'); ctx.stroke(); ctx.fillStyle='#cdd6e6'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.fillText(`${n.name} Lv${n.level}`, n.x, n.y-R-8); }}
  for(const u of state.units){ if(u.f==='PLAYER'){ ctx.save(); ctx.translate(u.x,u.y); ctx.fillStyle=(COLORS[u.f]||'#8899aa'); switch(UNIT[u.type].shape){ case 'circle': ctx.beginPath(); ctx.arc(0,0,3.5,0,Math.PI*2); ctx.fill(); break; case 'triangle': ctx.beginPath(); ctx.moveTo(0,-4); ctx.lineTo(4,4); ctx.lineTo(-4,4); ctx.closePath(); ctx.fill(); break; case 'square': ctx.fillRect(-3,-3,6,6); break; case 'diamond': ctx.beginPath(); ctx.moveTo(0,-4); ctx.lineTo(4,0); ctx.lineTo(0,4); ctx.lineTo(-4,0); ctx.closePath(); ctx.fill(); break; case 'rect': ctx.fillRect(-5,-3,10,6); break; } ctx.restore(); }}
  ctx.restore();
}


/* =============================
   HUD
============================= */
function updateHUD(){
  const timeSec=Math.floor(state.t); const m=Math.floor(timeSec/60), s=timeSec%60;
  statTime.textContent=`${m}:${s.toString().padStart(2,'0')}`;
  statUnits.textContent=state.units.length.toString();
  const myCities=state.nodes.filter(n=>n.owner==='PLAYER').length; statCities.textContent=myCities.toString();
  statSpeed.textContent=state.speed+'x';
}

/* =============================
   å¾ªç¯
============================= */
function tick(){
  const t=nowMs(); const raw=(t-state.last)/1000; state.last=t; state.dt=raw;
  if(!state.paused && !state.gameOver){
    const dt=state.dt; state.t+=dt*state.speed; produce(dt); updateAI(dt); updateUnits(dt); updateCaptureAndWall(dt);
    state.spawnTimer-=dt*state.speed; if(state.spawnTimer<=0){ state.spawnTimer=rand(10,18); spawnCity(); }
    checkGameState();
  }
  render(); updateHUD(); requestAnimationFrame(tick);
}

/* =============================
   äº¤äº’
============================= */
function pickNodeAt(x,y){ for(const n of state.nodes){ if(Math.hypot(x-n.x,y-n.y)<=nodeRadius(n)) return n; } return null; }

cvs.addEventListener('mousemove',e=>{ const r=cvs.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; const n=pickNodeAt(x,y); if(n){ tooltip.style.opacity=1; tooltip.style.transform=`translate(${x+12}px,${y+12}px)`; const wallMax=WALL_BASE*n.def*n.level; tooltip.innerHTML=`<b>${n.name}</b> Lv${n.level}<br>æ‰€å±ï¼š${n.owner}<br>äº§å…µï¼š${n.prod.toFixed(2)}/s<br>åŸé˜²ï¼š${Math.round(n.wall)}/${Math.round(wallMax)}`; } else { tooltip.style.opacity=0; } if(state.dragging && state.selected){ state.dragTo=n; } });

cvs.addEventListener('mousedown',e=>{ const r=cvs.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; const n=pickNodeAt(x,y); state.dragStart={x,y}; state.dragging=false; if(n && n.owner==='PLAYER'){ state.selected=n; } else { state.selected=null; cityPanel.style.display='none'; } });

cvs.addEventListener('mouseup',e=>{ const r=cvs.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; const n=pickNodeAt(x,y); const sel=state.selected; const moved = state.dragStart && Math.hypot(x-state.dragStart.x,y-state.dragStart.y)>8; if(sel && n && moved){ dispatch(sel,n,state.rallyPercent); } else if(sel && n===sel && !moved){ openCityPanel(n); } state.selected=null; state.dragTo=null; state.dragStart=null; state.dragging=false; });

cvs.addEventListener('mouseleave',()=>{ state.dragging=false; state.dragTo=null; });

cvs.addEventListener('mousemove',e=>{ if(state.dragStart){ const r=cvs.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; state.dragging = Math.hypot(x-state.dragStart.x,y-state.dragStart.y)>8; }});

btnPause.onclick=()=>{ state.paused=!state.paused; btnPause.textContent=state.paused?'ç»§ç»­':'æš‚åœ'; };
let speedIdx=0; btnSpeed.onclick=()=>{ speedIdx=(speedIdx+1)%TIME_SCALE_STEPS.length; state.speed=TIME_SCALE_STEPS[speedIdx]; btnSpeed.textContent='Ã—'+TIME_SCALE_STEPS[(speedIdx+1)%TIME_SCALE_STEPS.length]; };
btnMute.onclick=()=>{ btnMute.textContent = (btnMute.textContent==='é™éŸ³')?'å·²é™éŸ³':'é™éŸ³'; };
window.addEventListener('keydown',e=>{ if(e.key==='p'||e.key==='P') btnPause.click(); });

/* =============================
   åŸæ± é¢æ¿ï¼ˆæ¯”ä¾‹è”åŠ¨ï¼Œæ€»å’Œä¿æŒ 100ï¼‰
============================= */
let currentCity=null;
function openCityPanel(city){ currentCity=city; cityName.textContent=city.name; cityLevel.textContent=city.level; unitSliders.innerHTML=''; const types=ALL_TYPES;
  for(const type of types){ if(city.mix[type]===undefined) city.mix[type]=0; const row=document.createElement('div'); row.className='sliderRow'; const label=document.createElement('span'); label.className='label'; label.textContent=type; const slider=document.createElement('input'); slider.type='range'; slider.min=0; slider.max=100; slider.value=city.mix[type]; const val=document.createElement('span'); val.textContent=String(city.mix[type]).padStart(2,'0')+'%'; slider.oninput=()=>{ adjustMix(city,type,parseInt(slider.value)||0); // æ›´æ–°æ‰€æœ‰ slider å±•ç¤º
    for(const child of unitSliders.children){ const name=child.querySelector('.label').textContent; const s=child.querySelector('input'); const v=child.querySelector('span:last-child'); s.value=city.mix[name]; v.textContent=String(city.mix[name]).padStart(2,'0')+'%'; }
  }; row.appendChild(label); row.appendChild(slider); row.appendChild(val); unitSliders.appendChild(row);} cityPanel.style.display='flex'; }

function adjustMix(city,key,newVal){
  newVal=clamp(newVal,0,100);
  const otherKeys=ALL_TYPES.filter(k=>k!==key);
  const otherSum = otherKeys.reduce((s,k)=>s+(city.mix[k]||0),0);
  const totalTarget=100; const remain = clamp(totalTarget-newVal,0,100);
  if(otherSum<=0){ // å…¶ä»–å…¨ä¸º0ï¼Œç›´æ¥ç»™ keyï¼Œå‰©ä½™ç»™ä¸€ä¸ªé»˜è®¤é¡¹
    city.mix[key]=newVal; const spare=totalTarget-newVal; const fallback=otherKeys[0]; for(const k of otherKeys) city.mix[k]=0; city.mix[fallback]+=spare; return;
  }
  city.mix[key]=newVal; // å…¶ä»–æŒ‰æ¯”ä¾‹ç¼©æ”¾åˆ° remain
  for(const k of otherKeys){ const old=city.mix[k]||0; city.mix[k]=Math.round(old/otherSum*remain); }
  // æ•°å­¦å››èˆäº”å…¥è¯¯å·®ï¼Œåšä¸€æ¬¡æ ¡å‡†
  let sum=ALL_TYPES.reduce((s,k)=>s+(city.mix[k]||0),0);
  const diff=totalTarget-sum; if(diff!==0){ // æŠŠè¯¯å·®åŠ åˆ°æœ€å¤§çš„é‚£ä¸ª
    let tgt=otherKeys[0]; for(const k of otherKeys){ if((city.mix[k]||0)>(city.mix[tgt]||0)) tgt=k; }
    city.mix[tgt]=clamp((city.mix[tgt]||0)+diff,0,100);
  }
}

btnUpgrade.onclick=()=>{ if(!currentCity) return; if(currentCity.level>=5){ pushEvent('å·²è¾¾æœ€é«˜ç­‰çº§','bad'); return; } currentCity.level++; currentCity.prod=parseFloat((currentCity.prod*1.12).toFixed(2)); currentCity.def=parseFloat((currentCity.def*1.06).toFixed(2)); currentCity.wall=WALL_BASE*currentCity.def*currentCity.level; cityLevel.textContent=currentCity.level; pushEvent(`${currentCity.name} å‡çº§åˆ° Lv${currentCity.level}`,'good'); };

/* =============================
   è‡ªæ£€æµ‹è¯•ï¼ˆä¿ç•™åŸæœ‰ + æ–°å¢è‹¥å¹²ï¼‰
============================= */
function assert(cond,msg){ if(!cond){ console.error('âŒ '+msg); pushEvent('æµ‹è¯•å¤±è´¥ï¼š'+msg,'bad'); } }
function runTests(){
  // åŸæœ‰ç”¨ä¾‹ï¼šäº‹ä»¶ 3 æ¡
  pushEvent('T1'); pushEvent('T2'); pushEvent('T3'); pushEvent('T4'); assert(document.getElementById('events').children.length<=3,'äº‹ä»¶é¢æ¿â‰¤3');
  // åŸæœ‰ç”¨ä¾‹ï¼šæ¯”ä¾‹è”åŠ¨
  const city=state.nodes.find(n=>n.owner==='PLAYER'); const sum=()=>ALL_TYPES.reduce((s,k)=>s+(city.mix[k]||0),0);
  adjustMix(city,'éª‘å…µ',80); assert(sum()===100,'é…æ¯”æ€»å’Œ=100'); assert(city.mix['éª‘å…µ']===80,'éª‘å…µè¢«è®¾ç½®ä¸º80');
  // æ–°å¢ï¼šdispatch è‡ªèº«ä¸æŠ›é”™
  try{ dispatch(state.nodes[0], state.nodes[0], 0.5); assert(true,'dispatch è‡ªèº«ä¸æŠ›é”™'); }catch(e){ assert(false,'dispatch è‡ªèº«æŠ›é”™'); }
  // æ–°å¢ï¼šspawnCity ä¼šå¢åŠ åŸæ± æ•°é‡ï¼ˆä¸ä¿è¯ä¸€å®šè§¦å‘ï¼Œä½†è°ƒç”¨ä¸€æ¬¡åº”+1æˆ–è¢«è·ç¦»çº¦æŸå¿½ç•¥ï¼‰
  const before=state.nodes.length; spawnCity(); assert(state.nodes.length>=before,'spawnCity è‡³å°‘ä¿æŒæˆ–å¢åŠ åŸæ± æ•°');
  // æ–°å¢ï¼šè§†é‡åŠå¾„åº”è¦†ç›–å·±åŸåŠå¾„
  const myCity=state.nodes.find(n=>n.owner==='PLAYER'); assert(myCity && Math.max(VISION_CITY, nodeRadius(myCity)+20) > nodeRadius(myCity), 'è¿·é›¾å¼€æ´åŠå¾„>åŸæ± åŠå¾„');
}

/* =============================
   ç»“ç®—ä¸å¯åŠ¨
============================= */
function checkGameState(){
  const myCities=state.nodes.filter(n=>n.owner==='PLAYER').length;
  const myUnits=state.units.filter(u=>u.f==='PLAYER').length;
  if(myCities===0 && myUnits===0 && !state.gameOver){
    triggerDefeat();
  }
  const enemyLeft=state.nodes.some(n=>n.owner!=='PLAYER');
  if(!enemyLeft && myCities>0 && !state.gameOver){ triggerVictory(); }
}
function triggerDefeat(){ state.gameOver=true; overlayText.textContent='ä½ å·²å¤±å»æ‰€æœ‰åŸæ± å’Œéƒ¨é˜Ÿã€‚'; overlay.style.display='flex'; pushEvent('æˆ˜è´¥','bad'); }
function triggerVictory(){ state.gameOver=true; overlayText.textContent='ä½ å·²å é¢†å…¨éƒ¨åŸæ± ï¼Œèƒœåˆ©ï¼'; overlay.style.display='flex'; pushEvent('èƒœåˆ©ï¼','good'); }

btnRestart.onclick=()=>{ restart(); };
btnObserve.onclick=()=>{ overlay.style.display='none'; state.gameOver=false; };

function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
const MAP_ORIG=deepClone(MAP);
function restart(){
  // é‡ç½®çŠ¶æ€
  state.t=0; state.units.length=0; state.projs.length=0; state.edges.length=0; state.nodes.length=0;
  Object.assign(MAP, deepClone(MAP_ORIG));
  buildMap(); pushEvent('æ–°çš„ä¸€å±€å¼€å§‹','good');
}

function start(){ buildMap(); pushEvent('æ¬¢è¿æŒ‡æŒ¥å®˜ï¼Œæ‹–æ‹½å·±æ–¹åŸæ± å‘èµ·å‡ºå¾'); requestAnimationFrame(tick); setTimeout(runTests,200); }
start();

})();
</script>
</body>
</html>
